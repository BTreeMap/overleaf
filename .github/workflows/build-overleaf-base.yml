# Build overleaf-base image from upstream overleaf/overleaf
# This workflow builds the base image which contains dependencies and TeX Live
# Scheduled weekly to refresh dependencies, also triggered on push to main

name: Build Overleaf Base Image

on:
  schedule:
    # Weekly on Sunday at 00:00 UTC
    - cron: '0 0 * * 0'
  push:
    branches:
      - main
    paths:
      - '.github/workflows/build-overleaf-base.yml'
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild even if image exists'
        required: false
        default: 'false'
        type: boolean

env:
  REGISTRY: ghcr.io
  BASE_IMAGE_NAME: btreemap/overleaf-base

permissions:
  contents: read
  packages: write

jobs:
  detect-upstream:
    name: Detect Upstream State
    runs-on: ubuntu-latest
    outputs:
      edge_sha: ${{ steps.detect.outputs.edge_sha }}
      edge_sha_short: ${{ steps.detect.outputs.edge_sha_short }}
      build_date: ${{ steps.detect.outputs.build_date }}
      build_datetime: ${{ steps.detect.outputs.build_datetime }}
      should_build: ${{ steps.check.outputs.should_build }}
    steps:
      - name: Detect upstream edge SHA
        id: detect
        run: |
          python3 << 'EOF'
          import os
          import subprocess
          from datetime import datetime, timezone
          
          # Get the tip of main branch from upstream
          result = subprocess.run(
              ['git', 'ls-remote', 'https://github.com/overleaf/overleaf.git', 'refs/heads/main'],
              capture_output=True,
              text=True,
              timeout=30
          )
          edge_sha = result.stdout.split()[0] if result.stdout else ''
          edge_sha_short = edge_sha[:7]
          
          # Generate build timestamps
          now = datetime.now(timezone.utc)
          build_date = now.strftime('%Y-%m-%d')
          build_datetime = now.strftime('%Y-%m-%d.%H-%M-%S')
          
          # Write outputs
          github_output = os.environ.get('GITHUB_OUTPUT', '')
          if github_output:
              with open(github_output, 'a') as f:
                  f.write(f"edge_sha={edge_sha}\n")
                  f.write(f"edge_sha_short={edge_sha_short}\n")
                  f.write(f"build_date={build_date}\n")
                  f.write(f"build_datetime={build_datetime}\n")
          
          print(f"Detected upstream edge SHA: {edge_sha}")
          print(f"Build date: {build_date}")
          print(f"Build datetime: {build_datetime}")
          EOF

      - name: Check if image exists in GHCR
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'EOF'
          import os
          import subprocess
          
          edge_sha = "${{ steps.detect.outputs.edge_sha }}"
          image_tag = f"edge-sha-{edge_sha}"
          is_scheduled = "${{ github.event_name }}" == "schedule"
          force_rebuild = "${{ inputs.force_rebuild || 'false' }}" == "true"
          
          # For weekly builds, always rebuild
          if is_scheduled:
              print("Weekly scheduled build - forcing rebuild")
              should_build = "true"
          elif force_rebuild:
              print("Force rebuild requested")
              should_build = "true"
          else:
              # Check if image already exists
              result = subprocess.run(
                  ['docker', 'buildx', 'imagetools', 'inspect', f'ghcr.io/btreemap/overleaf-base:{image_tag}'],
                  capture_output=True,
                  timeout=60
              )
              if result.returncode == 0:
                  print(f"Image with tag {image_tag} already exists, skipping build")
                  should_build = "false"
              else:
                  print(f"Image tag {image_tag} not found, will build")
                  should_build = "true"
          
          github_output = os.environ.get('GITHUB_OUTPUT', '')
          if github_output:
              with open(github_output, 'a') as f:
                  f.write(f"should_build={should_build}\n")
          EOF

  build:
    name: Build ${{ matrix.platform }}
    needs: detect-upstream
    if: needs.detect-upstream.outputs.should_build == 'true'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
            arch: amd64
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
            arch: arm64
    steps:
      - name: Checkout upstream overleaf
        uses: actions/checkout@v4
        with:
          repository: overleaf/overleaf
          path: upstream
          ref: ${{ needs.detect-upstream.outputs.edge_sha }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }}
          labels: |
            org.opencontainers.image.title=Overleaf Base
            org.opencontainers.image.description=Base image for Overleaf with dependencies and TeX Live
            org.opencontainers.image.vendor=BTreeMap
            org.opencontainers.image.source=https://github.com/overleaf/overleaf
            org.opencontainers.image.revision=${{ needs.detect-upstream.outputs.edge_sha }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v6
        with:
          context: upstream
          file: upstream/server-ce/Dockerfile-base
          platforms: ${{ matrix.platform }}
          push: true
          labels: ${{ steps.meta.outputs.labels }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }},push-by-digest=true,name-canonical=true,push=true
          cache-from: type=gha,scope=overleaf-base-edge-${{ matrix.arch }}
          cache-to: type=gha,mode=max,scope=overleaf-base-edge-${{ matrix.arch }}

      - name: Export digest
        run: |
          python3 << 'EOF'
          import os
          
          digest = "${{ steps.build.outputs.digest }}"
          os.makedirs('/tmp/digests', exist_ok=True)
          digest_file = digest.replace('sha256:', '')
          open(f'/tmp/digests/{digest_file}', 'w').close()
          
          github_output = os.environ.get('GITHUB_OUTPUT', '')
          if github_output:
              with open(github_output, 'a') as f:
                  f.write(f"digest-${{ matrix.arch }}={digest}\n")
          EOF

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-base-${{ matrix.arch }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  merge:
    name: Create Multi-Arch Manifest
    needs: [detect-upstream, build]
    runs-on: ubuntu-latest
    steps:
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: digests-base-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }}
          tags: |
            # Immutable SHA tag
            type=raw,value=edge-sha-${{ needs.detect-upstream.outputs.edge_sha }}
            # Floating edge tag
            type=raw,value=edge
            # Date-based tags
            type=raw,value=edge-${{ needs.detect-upstream.outputs.build_date }}
            type=raw,value=edge-${{ needs.detect-upstream.outputs.build_datetime }}

      - name: Create manifest list and push
        working-directory: /tmp/digests
        run: |
          python3 << 'EOF'
          import json
          import os
          import subprocess
          
          metadata_json = os.environ.get('DOCKER_METADATA_OUTPUT_JSON', '{}')
          metadata = json.loads(metadata_json)
          
          tags = metadata.get('tags', [])
          tag_args = []
          for tag in tags:
              tag_args.extend(['-t', tag])
          
          # Get all digest files
          digests = []
          for f in os.listdir('.'):
              digests.append(f'ghcr.io/${{ env.BASE_IMAGE_NAME }}@sha256:{f}')
          
          cmd = ['docker', 'buildx', 'imagetools', 'create'] + tag_args + digests
          subprocess.run(cmd, check=True)
          EOF

      - name: Inspect image
        run: |
          python3 << 'EOF'
          import subprocess
          subprocess.run(
              ['docker', 'buildx', 'imagetools', 'inspect', 'ghcr.io/${{ env.BASE_IMAGE_NAME }}:edge'],
              check=True
          )
          EOF
